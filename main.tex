\documentclass[12pt]{article}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{epsfig}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[margin=3cm]{geometry}

\title{Monitoring the Galaxy Toolbox \\ Final Report \\ COSC480}
\author{Edward Hills \\ \\ Supervisor: Dr.\ David Eyers}

\begin{document}
\vspace{-1cm}

\maketitle

\section{Assignment 1}

To be honest, I still never fully understood, how the fake reading/writing was suppose to go. I realised that we should not write actual bytes (although I do memset a couple of buffers, just for fun), but I am not sure on how we were suppose to implement the read-ahead, write-behind buffers.

Here is a brief overview of my system.

\texttt{master.c} is the main thread and is responsible for creating and initialising the POSIX \texttt{pthreads} used to represent discs in the system and the worker threads. Once the discs and workers have been created, the workers will send a series of READ and WRITE requests for the discs to process. Once all requests have been processed the worker threads will quit and the master thread will send a QUIT message to each disc, once received the discs will also exit.

Each disc thread has has been set up to have two message queues, one for WRITE requests and one for READ requests. These have been implemented as circular buffers. The disc thread will then poll each queue for a message to process. Each message will contain a READ/WRITE/QUIT flag and a pointer to a monitor.

A monitor will contain a series of information needed to process the request. Once it has been processed a flag will be set informing the relevant worker thread it has completed. I tried to use \texttt{pthread\_cond\_wait(3)} and \texttt{pthread\_cond\_signal(3)} to signal the worker thread responsible for accepting the reply from the latest disc request. This however introduced a dead-lock I was unable to track down. After using \texttt{gprof} I found that the loop that checks for new requests is a major bottlekneck also, however because I have two message queues, it is not possible to use signalling and wait here. 

To me a message passing system would have been far more elegant.

\section{Assignment 2}

Making it message passing could help make asynchronisation easier. becasue can just og off and then be caled with data. would need to store a window of replies. in fact. it would be almost identical to the tcp sliding window protocol.

\end{document}
