\documentclass[12pt]{article}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{epsfig}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[margin=3cm]{geometry}

\title{Monitoring the Galaxy Toolbox \\ Final Report \\ COSC480}
\author{Edward Hills \\ \\ Supervisor: Dr.\ David Eyers}

\begin{document}
\vspace{-1cm}

\maketitle

\section{Assignment 1}

Here is a brief overview of my system.

\texttt{master.c} is the main thread and is responsible for creating and initialising the POSIX \texttt{pthreads} used to represent discs in the system and the worker threads. Once the discs and workers have been created, the workers will send a series of READ and WRITE requests for the discs to process. Once all requests have been processed the worker threads will quit and the master thread will send a QUIT message to each disc, once received the discs will also exit.-
Each disc thread has has been set up to have two message queues, one for WRITE requests and one for READ requests. These have been implemented as circular buffers. The disc thread will then poll each queue for a message to process. Each message will contain a READ/WRITE/QUIT flag and a pointer to a monitor.

A monitor will contain a series of information needed to process the request. Once it has been processed a flag will be set informing the relevant worker thread it has completed. I tried to use \texttt{pthread\_cond\_wait(3)} and \texttt{pthread\_cond\_signal(3)} to signal the worker thread responsible for accepting the reply from the latest disc request. This however introduced a dead-lock I was unable to track down. After using \texttt{gprof} I found that the loop that checks for new requests is a major bottleneck also, however because I have two message queues, it is not possible to use signalling and wait here. \texttt{sched\_yield(2) did make a large increase in performance however. Although, for smaller jobs or a computer with more CPU cores (I currently have two) it may not be as effective as the scheduler is unable to schedule the thread back in fast enough.

To be perfectly honest, I still never fully understood how the buffer rings was suppose to work. I realised that we should not write actual bytes (although I do memset a couple of buffers, just for fun), but I am not sure on how we were suppose to implement the read-ahead, write-behind buffers. Also an area of confusion I had, was the read when its full, write when its empty business.

To me a message passing system would have been far more elegant.

\section{Assignment 2}

If Assignment 1 had been implemented with a message-passing system instead of using shared memory, I believe that it would have been easier to maintain and develop. In essence, message-passing is where one process sends messages containing possibly complex data-structures to a series of recipients. Conceptually, this is not dissimilar to the approach taken in the first assignment, that is, a worker thread messages a disc with a request and a location to where it can find the data. In a message-passing system, instead of a pointer to shared-memory, it would be the actual data-structure and data itself.

Making it message passing could help make asynchronisation easier. becasue can just og off and then be caled with data. would need to store a window of replies. in fact. it would be almost identical to the tcp sliding window protocol.

\end{document}
